## 문제
[프로그래머스 - 단어 변환](https://school.programmers.co.kr/learn/courses/30/lessons/43163) <br>
: 알고리즘 - DFS

## 문제 풀이
### 사용 변수
- visited[] : 단어 사용 여부
- answer : 최종 답
- cnt : 각 싸이클 당 변환 횟수
- isConvertible 메소드 : 두 단어가 한글자만 다른지 true/false 리턴

### DFS 진행 과정
- 처음 시작 시, begin 과 target 의 일치 여부 검사 <br>
-> 재귀 시 begin 과 target 이 일치하는 단계에 도달했을 때 변환 수를 바로 리턴하게 하기 위해

- for 문을 통해 word의 단어 한개 당 사이클 생성 시도 <br>
-> 가장 작은 변환 횟수를 가진 사이클을 찾기 위해 전부 순회
- 안 사용한 단어 인지 && 한글자만 다른 단어라 변환이 가능한 단어 인지 확인 후 맞으면
- dfs 재귀를 사용해 다른 글자도 변환 하러 감
- ⭐️⭐️ 제귀가 끝나면 다음 word 단어 사이클을 돌때 visited[] 를 또 사용하기 위해 false로 값을 바꿔줌

## 오답 해결
### 상황

```java
dfs(words[i], target, words, cnt++);
```
dfs 재귀 탐색 시, 변환 횟수 추가를 `cnt++` 로 했더니 문제 결과값이 오답이었음 

### 이유

- `cnt + 1`은 cnt 자체를 변경하지 않고, 새로운 값을 반환
- `cnt++`는 후 cnt를 실제로 +1 해 변경
<br>
-> DFS에서는 각 호출이 새로운 상태를 검사하고, 이 호출이 끝나면 이전 상태로 돌아가야 합니다. 따라서, cnt는 각 호출에서 새롭게 관리되어야 함
-> 재귀가 끝나면 그 재귀 단계에 맞는 cnt 값을 사용해야하는데, cnt 값을 변경해버리면 안됨

### 새로운 의문
- **의문** : cnt의 데이터 타입은 int 로 기본 테이터 타입인데, cnt 의 값이 다른 dfs 메소드 끼리 이름이 같다고 같은 값을 가져가나?
- **해결** : 기본 데이터 타입이기 때문에 `cnt + 1` 일 때, 각 재귀 단게에 따라 다른 cnt 를 가짐 <br>
`cnt++` 은 후위 연산자로, 재귀를 시작한 새 dfs 에는 이전 cnt 원래 값을 배정하고, 재귀가 끝나면 ++ 를 해서 최종 값이 오답이었던 것

### 해결

```java
dfs(words[i], target, words, cnt + 1);
```

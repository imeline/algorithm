## 문제
[백준 14438번 - 수열과 쿼리 17](https://www.acmicpc.net/problem/14438) <br>
- 알고리즘 : `세그먼트 트리`
- [블로그 정리](https://velog.io/@imeline/%ED%8A%B8%EB%A6%AC)

## 문제 풀이
1. 트리 초기화
    - 리프노드의 깊이 `K` 를  `2^K >= N`를 구한다.
      - N 은 문제에서 주어지는 수열 값들
        - N 만큼 리프노드가 생성되어야하므로, N 보다 크거나 같은 2^K 이 리프노드의 수이고 <br>
            트리는 1, 2, 4, 8.. 순서대로 2의 제곱만큼 노드가 한 높이당 생성되므로 K 가 리프노트의 깊이
    - 트리 사이즈(포화 트리의 전체 노드 수) `2^(K+1)` 을 구한다. 
      - K+1 은 트리 높이, 예를 들어 4가 트리 높이면 16이 전체노드 수. <br>
        한 층당 1, 2, 4, 8 이므로 합이 15. 0번 노드는 사용하지 않지만 트리 사이즈에 포함 되서 15 + 1 = 16
    - 리프 노드 시작 인덱스 `2^K`를 구한다.
      - 2^(자신의 부모 노드의 트리 높이)
    - `리프 노드 시작 인덱스` 부터 주어진 수열 값 넣기
    - `리프 노드 상위 노드들`에 왼쪽 노드와 오른쪽 노드 중 문제(최대, 최소, 부분값)에 해당하는거 넣음
            
2. 문제 값(최소, 최대, 부분합) 구하기
    - start 와 end 인덱스 -> 리프노드 인덱스로 변경
    - start 가 오른쪽 노드(홀수), end가 왼쪽 노드(짝수) 일 때 계산 반영 노드로 선택
      - 각 홀수, 짝수가 아니라면 범위를 벗어낫거나,
      - 부모 노드에 이미 계산 되어있어 부모 노드만 보면 되는 경우
      - ex) start 가 왼쪽 노드인 경우 `start/=2` 의 식을 통해 부모노드로 가서 <br> 
        부모노드에 start와 start 오른쪽 노드 계산 값이 있어 start 볼 필요 X <br>
        start 가 오른쪽 노드인 경우 `(start+1)/2` 인 부모 노드로 가기 때문에 <br>
        start 의 부모가 아니라 그 오른쪽의 부모로 가기 때문에 start 반영 필요
    - 각 부모 노드로 가기 위한 `start/=2` 실행
    - start < end 보다 작거나 같을 때 까지 반복 - start가 end 보다 크다면 start ~ end 범위를 벗어난 것
3. 트리 업데이트
    - 업데이트 해야하는 인덱스를 노드 인덱스로 바꾸고, 업데이트 값을 대입
    - 업데이트 된 리프 노드를 기준으로 왼쪽, 오른쪽 노드를 비교해가며 상단 부모 노드 값도 다 바꿈


## 코드 개선
```java
int tree_size = (int)Math.pow(2, K + 1);
leaf_start_idx = (int)Math.pow(2, K);
```
⬇️
```java
int tree_size = 1 << (K + 1); // K+1 은 트리 높이, 2^트리높이 는 포화 트리의 전체 노드 수
leaf_start_idx = 1 << K;
```
- 2의 제곱을 구하는 식을 비트로 계산 간단히 함